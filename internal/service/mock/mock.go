// Code generated by MockGen. DO NOT EDIT.
// Source: internal/service/service.go

// Package mock_service is a generated GoMock package.
package mock_service

import (
	zip "archive/zip"
	models "doodocs_task/models"
	multipart "mime/multipart"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockUnziper is a mock of Unziper interface.
type MockUnziper struct {
	ctrl     *gomock.Controller
	recorder *MockUnziperMockRecorder
}

// MockUnziperMockRecorder is the mock recorder for MockUnziper.
type MockUnziperMockRecorder struct {
	mock *MockUnziper
}

// NewMockUnziper creates a new mock instance.
func NewMockUnziper(ctrl *gomock.Controller) *MockUnziper {
	mock := &MockUnziper{ctrl: ctrl}
	mock.recorder = &MockUnziperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnziper) EXPECT() *MockUnziperMockRecorder {
	return m.recorder
}

// IsArchive mocks base method.
func (m *MockUnziper) IsArchive(fileHeader multipart.FileHeader) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsArchive", fileHeader)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsArchive indicates an expected call of IsArchive.
func (mr *MockUnziperMockRecorder) IsArchive(fileHeader interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsArchive", reflect.TypeOf((*MockUnziper)(nil).IsArchive), fileHeader)
}

// ProccesingArchive mocks base method.
func (m *MockUnziper) ProccesingArchive(file multipart.File, fileHeader multipart.FileHeader) (models.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ProccesingArchive", file, fileHeader)
	ret0, _ := ret[0].(models.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProccesingArchive indicates an expected call of ProccesingArchive.
func (mr *MockUnziperMockRecorder) ProccesingArchive(file, fileHeader interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProccesingArchive", reflect.TypeOf((*MockUnziper)(nil).ProccesingArchive), file, fileHeader)
}

// MockZiper is a mock of Ziper interface.
type MockZiper struct {
	ctrl     *gomock.Controller
	recorder *MockZiperMockRecorder
}

// MockZiperMockRecorder is the mock recorder for MockZiper.
type MockZiperMockRecorder struct {
	mock *MockZiper
}

// NewMockZiper creates a new mock instance.
func NewMockZiper(ctrl *gomock.Controller) *MockZiper {
	mock := &MockZiper{ctrl: ctrl}
	mock.recorder = &MockZiperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockZiper) EXPECT() *MockZiperMockRecorder {
	return m.recorder
}

// AddToZip mocks base method.
func (m *MockZiper) AddToZip(zipWriter *zip.Writer, file *multipart.FileHeader) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddToZip", zipWriter, file)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddToZip indicates an expected call of AddToZip.
func (mr *MockZiperMockRecorder) AddToZip(zipWriter, file interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddToZip", reflect.TypeOf((*MockZiper)(nil).AddToZip), zipWriter, file)
}

// CheckFile mocks base method.
func (m *MockZiper) CheckFile(file *multipart.FileHeader) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckFile", file)
	ret0, _ := ret[0].(bool)
	return ret0
}

// CheckFile indicates an expected call of CheckFile.
func (mr *MockZiperMockRecorder) CheckFile(file interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckFile", reflect.TypeOf((*MockZiper)(nil).CheckFile), file)
}

// CreateZipArchive mocks base method.
func (m *MockZiper) CreateZipArchive(files []*multipart.FileHeader) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateZipArchive", files)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateZipArchive indicates an expected call of CreateZipArchive.
func (mr *MockZiperMockRecorder) CreateZipArchive(files interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateZipArchive", reflect.TypeOf((*MockZiper)(nil).CreateZipArchive), files)
}

// MockEmail is a mock of Email interface.
type MockEmail struct {
	ctrl     *gomock.Controller
	recorder *MockEmailMockRecorder
}

// MockEmailMockRecorder is the mock recorder for MockEmail.
type MockEmailMockRecorder struct {
	mock *MockEmail
}

// NewMockEmail creates a new mock instance.
func NewMockEmail(ctrl *gomock.Controller) *MockEmail {
	mock := &MockEmail{ctrl: ctrl}
	mock.recorder = &MockEmailMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEmail) EXPECT() *MockEmailMockRecorder {
	return m.recorder
}

// CheckFile mocks base method.
func (m *MockEmail) CheckFile(file *multipart.FileHeader) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckFile", file)
	ret0, _ := ret[0].(bool)
	return ret0
}

// CheckFile indicates an expected call of CheckFile.
func (mr *MockEmailMockRecorder) CheckFile(file interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckFile", reflect.TypeOf((*MockEmail)(nil).CheckFile), file)
}

// FileToBytes mocks base method.
func (m *MockEmail) FileToBytes(file *multipart.FileHeader) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FileToBytes", file)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FileToBytes indicates an expected call of FileToBytes.
func (mr *MockEmailMockRecorder) FileToBytes(file interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FileToBytes", reflect.TypeOf((*MockEmail)(nil).FileToBytes), file)
}

// SendFileToEmails mocks base method.
func (m *MockEmail) SendFileToEmails(fileBytes []byte, filename, mimeType string, emails []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendFileToEmails", fileBytes, filename, mimeType, emails)
	ret0, _ := ret[0].(error)
	return ret0
}

// SendFileToEmails indicates an expected call of SendFileToEmails.
func (mr *MockEmailMockRecorder) SendFileToEmails(fileBytes, filename, mimeType, emails interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendFileToEmails", reflect.TypeOf((*MockEmail)(nil).SendFileToEmails), fileBytes, filename, mimeType, emails)
}
